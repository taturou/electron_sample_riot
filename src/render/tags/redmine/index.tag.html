<redmine>
  <notification></notification>
  <div class="contentes">
    <div class="functions">
      <input class="input" type="text" value="10" ref="limit" />
      <span class="button" onclick="{issues}"><span id="download-btn"> issues</span></span>
      <span class="button" onclick="{users}"><span id="download-btn"> users</span></span>
      <span class="button" onclick="{projects}"><span id="download-btn"> projects</span></span>
      <span class="button" onclick="{clear}"><fa fa="trash-o" /></span>
    </div>
    <div id="table"></div>
  </div>

  <script>
    import riot from 'riot';
    import Handsontable from 'handsontable';
    import {dispatch, subscribe, unsubscribe} from 'businessman';

    const download_button = {
      element: 'span#download-btn',
      icons: {
        normal: 'cloud-download',
        spin: 'spinner'
      }
    };

    let tag = this;
    tag.hot = null;
    tag.issues = issues;
    tag.users = users;
    tag.projects = projects;
    tag.clear = clear;
    tag.toggle_icons = toggle_icons;

    function issues() {
      tag.toggle_icons(download_button, true);
      dispatch('redmine', 'issues', {limit: tag.refs.limit.value});
    }

    function users() {
      tag.toggle_icons(download_button, true);
      dispatch('redmine', 'users', {limit: tag.refs.limit.value});
    }

    function projects() {
      tag.toggle_icons(download_button, true);
      dispatch('redmine', 'projects', {limit: tag.refs.limit.value});
    }

    function clear() {
      dispatch('redmine', 'clear');
    }

    function toggle_icons(obj, is_spin) {
      let option = {};
      if (is_spin) {
        option = {
          fa: obj.icons.spin,
          fw: true,
          spin: true
        };
      } else {
        option = {
          fa: obj.icons.normal,
          fw: true,
        };
      }

      riot.mount(obj.element, 'fa', option);
    }

    tag.on('mount', () => {
      let container = document.getElementById('table');
      tag.hot = new Handsontable(container, {
        data: [],
        dataSchema: {
          id: null,
          tracker: {name: null},
          status: {name: null},
          subject: null,
          project: {name: null},
          assigned_to: {name: null}
        },
        colHeaders: ['#', 'Tracker', 'Status', 'Subject', 'Project', 'Assigned'],
        columns: [
          {data: 'id'},
          {data: 'tracker.name'},
          {data: 'status.name'},
          {data: 'subject'},
          {data: 'project.name'},
          {data: 'assigned_to.name'}
        ],
        readOnly: true,
        columnSorting: true,
        sortIndicator: true,
      });

      tag.toggle_icons(download_button, false);

      subscribe('redmine', (state, mutationType) => {
        console.log(JSON.stringify(state));
        if (mutationType === 'error') {
          dispatch('notification', 'push', 'Redmine access error');
        } else {
          tag.hot.updateSettings({
            data: state.issues
          });
        }
        tag.toggle_icons(download_button, false);
      });
    });

    tag.on('unmount', () => {
      unsubscribe('redmine');
    });
  </script>

  <style type="scss">
    .contents {
      padding: 10px;
      flex: 1;
      flex-direction: column;
    }
    .functions {
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
    }
    .button {
      border: 1px solid black;
      padding: 1px 6px;
      background: #f5f5f4;
    }
  </style>
</redmine>